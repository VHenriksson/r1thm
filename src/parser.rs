use pest::Parser;
use pest_derive::Parser;
use std::collections::HashMap;

use crate::r1cs::R1CS;
use crate::r1cs_constraint::{R1CSConstraint, R1CSSumConstraint};



#[derive(Parser)]
#[grammar = "poly.pest"]
/// A struct implementing a polynomial parser based on the
/// grammar defined in *poly.pest*.
struct PolyParser;

/// A visitor which visits the nodes of the parse tree generated by the
/// `PolyParser` and creates new matching constraints for an `R1CS`.
struct ParseTreeVisitor {
    visited_nodes: HashMap<(Rule, String), usize>, 
    r1cs: R1CS,
}

impl ParseTreeVisitor {
    /// Creates a new `ParseTreeVisitor` instance.
    fn new() -> Self {
        ParseTreeVisitor {
            visited_nodes: HashMap::new(),
            r1cs: R1CS::new(),
        }
    }

    /// A wrapper function which checks if an identical node has already been visited.
    /// In this case, no new constraints should be created, since this sub-polynomial
    /// has already been given a variable. Instead this variable is returned.
    fn cache_wrapper<F>(&mut self, f: F, pair: pest::iterators::Pair<Rule>) -> usize
    where F: for<'a> Fn(&'a mut Self, pest::iterators::Pair<Rule>) -> usize
    {
        let key = (pair.as_rule(), pair.as_str().to_string());
        if self.visited_nodes.contains_key(&key) {
            self.visited_nodes[&key]
        } else {
            let variable = f(self, pair);
            self.visited_nodes.insert(key, variable);
            variable
        }
    }

    /// Visits a variable node in the parse tree and adds it to the R1CS as input.
    fn visit_variable(&mut self, variable_pair: pest::iterators::Pair<Rule>) -> usize {
        self.cache_wrapper(|s, input_pair| {
            s.r1cs.add_input_variable(input_pair.as_str().to_string())
        } , variable_pair)
    }

    /// Visits a variable exponentiation node in the parse tree and creates the corresponding
    /// constraints in the R1CS. 
    fn visit_varpow(&mut self, varpow_pair: pest::iterators::Pair<Rule>) -> usize {
        self.cache_wrapper(|s, input_pair| {
            let mut exponent = 1;
            let mut variable_position = 0;
            for pair in input_pair.into_inner() {
                match pair.as_rule() {
                    Rule::variable => {
                        variable_position = s.visit_variable(pair);
                    }
                    Rule::exponent => {
                        exponent = pair.as_str().parse().expect("Not a number");
                    }
                    _ => {
                        println!("Unhandled varpow: {:?}", pair.as_rule());
                    }
                }
            }            
            s.create_exponentiation_constraints(exponent, variable_position)
        }, varpow_pair)
    }

    /// Creates constraints from exponentiations.
    /// 
    /// Note that for any exponentiation where the power is larger than 2, we need
    /// to create multiple constraints. We do this using binary exponentiation, in order
    /// to keep the number of constraints low.
    /// 
    /// Constraints created by this function are of the form `u_i * u_j = u_k`,
    /// where `u_i` and `u_j` are powers of the variable and `u_k` is a new power.
    /// 
    /// **Note**: This function ignores checking whether there is already a varible for
    /// any of the intermediate powers. This is a potential optimization (if optimizing for
    /// a minimal number of variables; the effect on performace would depend on the input
    /// polynomial), but has not been implemented yet.
    fn create_exponentiation_constraints(&mut self, mut exponent: i32, variable_position: usize) -> usize {
        if exponent == 1 {
            variable_position
        } else {
            let max_exponent_variable = self.r1cs.add_variable();
            let mut current_exponent_variable = max_exponent_variable;
            while exponent > 1 {
                if exponent % 2 == 0 {
                    exponent /= 2;
                    if exponent == 1 {
                        self.r1cs.add_constraint(R1CSConstraint::new_multiplication_constraint(variable_position, variable_position, current_exponent_variable));
                    } else {
                        let new_exponent_variable = self.r1cs.add_variable();
                        self.r1cs.add_constraint(R1CSConstraint::new_multiplication_constraint(new_exponent_variable, new_exponent_variable, current_exponent_variable));
                        current_exponent_variable = new_exponent_variable;
                    }
                } else {
                    let new_exponent_variable = self.r1cs.add_variable();
                    self.r1cs.add_constraint(R1CSConstraint::new_multiplication_constraint(variable_position, new_exponent_variable, current_exponent_variable));
                    exponent -= 1;
                    current_exponent_variable = new_exponent_variable;
                }
            }
            max_exponent_variable
        }
    }
    
    /// Visits a factor node in the parse tree. This function does not create any new constraints,
    /// but instead returns the variable corresponding to the node that the factor consists of
    /// (a varpow or a parenth).
    /// 
    /// In particular, this means that the function does not need the wrapper function `cache_wrapper`.
    fn visit_factor(&mut self, factor_pair: pest::iterators::Pair<Rule>) -> usize {
        let mut variable_position = 0;
        for pair in factor_pair.into_inner() {
            match pair.as_rule() {
                Rule::varpow => {
                    variable_position = self.visit_varpow(pair);
                }
                Rule::parenth => {
                    variable_position = self.visit_parenth(pair);
                }
                _ => {
                    println!("Unhandled factor: {:?}", pair.as_rule());
                }
            }
        }
        variable_position
    }

    /// Visits a C-factor node in the parse tree (i.e. a factor containing a constant together with a varpow or parenth).
    /// If the constant is not 1, a new variable is created representing this factor and a constraint is added to the R1CS.
    /// Otherwise, the original variable of the factor is returned.
    /// 
    /// Constraints created by this function are of the form `c * u_j = u_k`, where `c` is the constant,
    /// `u_j` is the variable of the factor and `u_k` is the new variable.
    fn visit_cfactor(&mut self, cfactor_pair: pest::iterators::Pair<Rule>) -> usize {
        self.cache_wrapper(|s, input_pair| {
            let mut variable_position = 0;
            let mut variable_constant = 1;
            for pair in input_pair.into_inner() {
                match pair.as_rule() {
                    Rule::constant => {
                        variable_constant = pair.as_str().parse().expect("Not a number");
                    }
                    Rule::factor => {
                        variable_position = s.visit_factor(pair);
                    }
                    _ => {
                        println!("Unhandled C-factor: {:?}", pair.as_rule());
                    }
                }
            }
            if variable_constant != 1 {
                let cfactor_variable = s.r1cs.add_variable();
                s.r1cs.add_constraint(R1CSConstraint::new_constant_multiplication_constraint(variable_constant, variable_position, cfactor_variable));
                cfactor_variable
            } else {
                variable_position
            }
        }, cfactor_pair)
    }

    /// Visits a parenthesis node in the parse tree, and creates the corresponding constraints in the R1CS.
    fn visit_parenth(&mut self, parenth_pair: pest::iterators::Pair<Rule>) -> usize {
        self.cache_wrapper(|s, input_pair| {
            let mut exponent = 1;
            let mut variable_position = 0;
            for pair in input_pair.into_inner() {
                match pair.as_rule() {
                    Rule::expression => {
                        variable_position = s.visit_expression(pair);
                    }
                    Rule::exponent => {
                        exponent = pair.as_str().parse().expect("Not a number");
                    }
                    _ => {
                        println!("Unhandled parenthesis: {:?}", pair.as_rule());
                    }
                }
            }
            s.create_exponentiation_constraints(exponent, variable_position)
        }, parenth_pair)
    }

    /// Visits a product node in the parse tree and creates the corresponding constraints in the R1CS.
    fn visit_product(&mut self, product_pair: pest::iterators::Pair<Rule>) -> usize {
        self.cache_wrapper(|s, input_pair| {
            let mut variable_positions = Vec::new();
            for pair in input_pair.into_inner() {
                match pair.as_rule() {
                    Rule::cfactor => {
                        variable_positions.push(s.visit_cfactor(pair));
                    }
                    Rule::factor => {
                        variable_positions.push(s.visit_factor(pair));
                    }
                    _ => {
                        println!("Unhandled product: {:?}", pair.as_rule());
                    }
                }
            }
            // If the product is empty, we return the variable position 0,
            // which is the identity element for multiplication.
            // However, this should not happen?
            if variable_positions.len() == 0 {
                0
            } else {
                let mut current_variable = variable_positions[0];
                println!("Current variable: {}", current_variable);
                for position in variable_positions.iter().skip(1) {
                    let product_variable = s.r1cs.add_variable();
                    s.r1cs.add_constraint(R1CSConstraint::new_multiplication_constraint(current_variable, *position, product_variable));
                    current_variable = product_variable;
                }
                current_variable
            }
        }, product_pair)
    }

    /// Visits a term node in the parse tree. If the node is a constant, a new variable is created
    /// and a constraint is added to the R1CS. Otherwise, the function just returns the variable
    /// corresponding to the inner node (TODO: It would probably be cleaner to add the new variable
    /// in a separate "add_constant" function, so that this function does not need to create any
    /// new constraints).
    fn visit_term(&mut self, term_pair: pest::iterators::Pair<Rule>) -> usize {
        self.cache_wrapper(|s, input_pair| {
            let mut variable_position = 0;
            for pair in input_pair.into_inner() {
                match pair.as_rule() {
                    Rule::cfactor => {
                        variable_position = s.visit_cfactor(pair);
                    }
                    Rule::product => {
                        variable_position = s.visit_product(pair);
                    }
                    Rule::constant => {
                        let constant = pair.as_str().parse().expect("Not a number");
                        variable_position = s.r1cs.add_variable();
                        s.r1cs.add_constraint(R1CSConstraint::new_constant_constraint(constant, variable_position));
                    }
                    _ => {
                        println!("Unhandled term: {:?}", pair.as_rule());
                    }
                }
            }
            variable_position
        }, term_pair)
    }

    /// Visits an add_term or sub_term node in the parse tree. This function does not create any new constraints,
    /// but instead returns the variable corresponding to the node that the term consists of.
    /// 
    /// In particular, this means that the function does not need the wrapper function `cache_wrapper`.
    fn visit_add_or_sub_term(&mut self, add_or_sub_pair: pest::iterators::Pair<Rule>) -> usize {
        let mut variable_position = 0;
        for pair in add_or_sub_pair.into_inner() {
            match pair.as_rule() {
                Rule::term => {
                    variable_position = self.visit_term(pair);
                }
                _ => {
                    println!("Unhandled factor: {:?}", pair.as_rule());
                }
            }
        }
        variable_position
    }

    /// Visits an expression node in the parse tree and creates the corresponding constraints in the R1CS. 
    fn visit_expression(&mut self, expression_pair: pest::iterators::Pair<Rule>) -> usize {
        self.cache_wrapper(|s, input_pair| {
            let mut new_constraint = R1CSSumConstraint::new();
            let mut should_create_new_variable = false;
            let mut fallthrough_variable = 0;
            for pair in input_pair.into_inner() {
                match pair.as_rule() {
                    Rule::term => {
                        fallthrough_variable = s.visit_term(pair);
                        new_constraint.add_to_sum(fallthrough_variable);
                    }
                    Rule::add_term => {
                        new_constraint.add_to_sum(s.visit_add_or_sub_term(pair));
                        should_create_new_variable = true;
                    }
                    Rule::sub_term => {
                        new_constraint.subtract_from_sum(s.visit_add_or_sub_term(pair));
                        should_create_new_variable = true;
                    }
                    _ => {
                        println!("Unhandled expression: {:?}", pair.as_rule());
                    }
                }
            }
            if should_create_new_variable {
                let expression_variable = s.r1cs.add_variable();
                new_constraint.set_right_hand_side(expression_variable);
                s.r1cs.add_constraint(new_constraint.to_r1cs_constraint());
                expression_variable
            } else {
                fallthrough_variable
            }
        }, expression_pair)
    }  

    /// Generates a R1CS system from the visited nodes in the parse tree.
    fn generate_r1cs(mut self, expression_pair: pest::iterators::Pair<Rule>, expected_result : i64) -> R1CS {
        // Placeholder for generating the R1CS system from the visited nodes
        let variable_position = self.visit_expression(expression_pair);
        self.r1cs.add_constraint(R1CSConstraint::new_final_constraint(expected_result, variable_position));
        self.r1cs
    }
}






/// Parses a polynomial and generates a R1CS system from it.
/// 
/// This is the main function of the r1thm library. It takes a polynomial, given as a 
/// string, and an expected result (i.e. an equation of the form `p(x_1, ..., x_n) = c`
/// for some expected_result `c`), and returns a R1CS system representing the polynomial.
/// 
/// The function uses a polynomial grammar defined in *poly.pest* to parse the polynomial.
/// If the polynomial does not follow the grammar, the function may return errouneous results.
pub fn poly2r1cs(polynomial: String, expected_result : i64) -> Result<R1CS, String>  { 

    let visitor = ParseTreeVisitor::new();
    match PolyParser::parse(Rule::expression, polynomial.as_str()) {
        Ok(mut pairs) => {
            let expression = pairs.next().unwrap();

            Ok(visitor.generate_r1cs(expression, expected_result))
        }
        Err(e) => Err(format!("Error parsing polynomial: {}", e)),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    /// Helper function to test that the system has the correct variables, as well as returning
    /// the indices of their variables.
    fn get_variable_positions(r1cs: &R1CS, variables: Vec<String>) -> HashMap<String, usize> {
        let mut variable_positions = HashMap::new();
        assert_eq!(r1cs.input_size(), variables.len(), "Expected {} variables, found {}", variables.len(), r1cs.input_size());
        for variable in variables {
            let position = r1cs.get_variable_index(&variable);
            assert!(position.is_some(), "Variable {} not found", variable);
            let position = position.unwrap();
            assert_ne!(position, 0, "Variable {} has position 0", variable);
            for (other_variable, other_position) in variable_positions.iter() {
                assert_ne!(position, *other_position, "Variable {} has the same position as {}", variable, other_variable);
            }
            variable_positions.insert(variable, position);
        }
        variable_positions
    }

    /// Helper function to check that there is a constraint matching a given form in the R1CS, and
    /// if so, return the variable on the right hand side of the constraint (note that all R1CS
    /// constraints generated by `poly2r1cs` will only have one nonzero term on the right hand side).
    fn handle_constraint(r1cs: &R1CS, expected_a: HashMap<usize, i64>, expected_b: HashMap<usize, i64>) -> usize {
        let matching_constraint = r1cs.find_matching_constraint(&expected_a, &expected_b, None);
        assert!(matching_constraint.is_some(), "Looking for constraint on form ({}) * ({}). No matching constraint found", expected_a.iter().map(|(k, v)| if *k != 0 {format!("{}a_{}", v, k)} else {format!("{}", v)}).collect::<Vec<_>>().join(" + "), expected_b.iter().map(|(k, v)| format!("{}a_{}", v, k)).collect::<Vec<_>>().join(" + "));
        let matching_constraint = matching_constraint.unwrap();
        let c_pairs = matching_constraint.get_c_pairs();
        assert_eq!(c_pairs.len(), 1, "Expected exactly one entry in c");
        let (c_key, c_value) = c_pairs.iter().next().unwrap();
        assert_eq!(*c_value, 1, "Expected c value to be 1");
        *c_key
    }

    /// Checks the final constraint, asserting that the variable matching the full polynomial
    /// will be equal to the expected result.
    fn check_final_constraint(r1cs: &R1CS, expected_final_variable: usize, expected_c: i64) {
        let expected_a = HashMap::from([(0, 1)]);
        let expected_b = HashMap::from([(expected_final_variable, 1)]);
        let expected_c = HashMap::from([(0, expected_c)]);
        let matching_constraint = r1cs.find_matching_constraint(&expected_a, &expected_b, Some(&expected_c));
        assert!(matching_constraint.is_some(), "No matching constraint found");
    }

    /// Check that a constraint which adds and subtracts variables is present in the R1CS.
    /// 
    /// The vector `variables_to_add_with_signs` contains pairs of variable indices and signs.
    /// The indices are the indices of the variables to add or subtract, and the signs tell 
    /// whether to add or subtract the variable (1 for addition, -1 for subtraction).
    fn handle_add_constraint(r1cs: &R1CS, variables_to_add_with_signs: Vec<(usize, i8)>) -> usize {
        let expected_a = HashMap::from([(0, 1)]);
        let mut expected_b = HashMap::new();
        for (variable, sign) in variables_to_add_with_signs {
            assert!(sign == 1 || sign == -1);
            expected_b.insert(variable, sign as i64);
        }
        handle_constraint(r1cs, expected_a, expected_b)
    }

    /// Check that a constraint corresponding to a simple constant (i.e. `c = u_k` for some
    /// constant `c` and variable `u_k`) is present in the R1CS.
    fn handle_const_constraint(r1cs: &R1CS, constant: i64) -> usize {
        let expected_a = HashMap::from([(0, 1)]);
        let expected_b = HashMap::from([(0, constant)]);
        handle_constraint(r1cs, expected_a, expected_b)
    }

    /// Check that a constraint corresponding to a constant multiplication (i.e. `c * u_j = u_k`
    /// for some constant `c` and variables `u_j` and `u_k`) is present in the R1CS.
    /// 
    /// The input is the constant `c` and the variable index `j`. It returns the index `k`.
    fn handle_const_mult_constraint(r1cs: &R1CS, c: i64, j: usize) -> usize {
        let expected_a = HashMap::from([(0, c)]);
        let expected_b = HashMap::from([(j, 1)]);
        handle_constraint(r1cs, expected_a, expected_b)
    }

    /// Check that a constraint corresponding to a multiplication (i.e. `u_i * u_j = u_k`
    /// for some variables `u_i`, `u_j` and `u_k`) is present in the R1CS.
    /// 
    /// The input is the variable indices `i` and `j`. It returns the index `k`.
    fn handle_mult_constraint(r1cs: &R1CS, i: usize, j: usize) -> usize {
        let expected_a = HashMap::from([(i, 1)]);
        let expected_b = HashMap::from([(j, 1)]);
        handle_constraint(r1cs, expected_a, expected_b)
    }

    /// Helper function to parse a polynomial and check that the result is correct.
    fn parse(polynomial: String, expected_result : i64) -> R1CS {
        let result = poly2r1cs(polynomial, expected_result);
        assert!(result.is_ok(), "Error parsing polynomial: {:?}", result.err());
        result.unwrap() 
    }
    
    #[test]
    fn test_basic_sum() {
        let polynomial = "y + x + z".to_string();
        let expected_result = 31;
        let parsed_poly = parse(polynomial, expected_result);
        let pos = get_variable_positions(&parsed_poly, vec!["x".to_string(), "y".to_string(), "z".to_string()]);
        let final_variable = handle_add_constraint(&parsed_poly, vec![(pos["x"],1), (pos["y"],1), (pos["z"],1)]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_basic_sum_with_coefficients() {
        let polynomial = "67x + 7*y".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        let mut pos = get_variable_positions(&parsed_poly, vec!["x".to_string(), "y".to_string()]);
        pos.insert("67x".to_string(), handle_const_mult_constraint(&parsed_poly, 67, pos["x"]));
        pos.insert("7*y".to_string(), handle_const_mult_constraint(&parsed_poly, 7, pos["y"]));
        parsed_poly.print();
        let final_variable = handle_add_constraint(&parsed_poly, vec![(pos["67x"],1), (pos["7*y"],1)]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_basic_sum_with_constant() {
        let polynomial = "7 + 2x + 3y".to_string();
        let expected_result = 70;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let mut pos = get_variable_positions(&parsed_poly, vec!["x".to_string(), "y".to_string()]);
        pos.insert("7".to_string(), handle_const_constraint(&parsed_poly, 7));
        pos.insert("2x".to_string(), handle_const_mult_constraint(&parsed_poly, 2, pos["x"]));
        pos.insert("3y".to_string(), handle_const_mult_constraint(&parsed_poly, 3, pos["y"]));
        parsed_poly.print();
        let final_variable = handle_add_constraint(&parsed_poly, vec![(pos["7"],1), (pos["2x"],1), (pos["3y"],1)]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_basic_product() {
        let polynomial = "x*y".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let pos = get_variable_positions(&parsed_poly, vec!["x".to_string(), "y".to_string()]);
        let final_variable = handle_mult_constraint(&parsed_poly, pos["x"], pos["y"]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_recurring_product() {
        let polynomial = "x*y*z*a*b*c".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let mut pos = get_variable_positions(&parsed_poly, vec!["x".to_string(), "y".to_string(), "z".to_string(), "a".to_string(), "b".to_string(), "c".to_string()]);
        pos.insert("x*y".to_string(), handle_mult_constraint(&parsed_poly, pos["x"], pos["y"]));
        pos.insert("x*y*z".to_string(), handle_mult_constraint(&parsed_poly, pos["x*y"], pos["z"]));
        pos.insert("x*y*z*a".to_string(), handle_mult_constraint(&parsed_poly, pos["x*y*z"], pos["a"]));
        pos.insert("x*y*z*a*b".to_string(), handle_mult_constraint(&parsed_poly, pos["x*y*z*a"], pos["b"]));
        let final_variable = handle_mult_constraint(&parsed_poly, pos["x*y*z*a*b"], pos["c"]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_simple_exponentiation() {
        let polynomial = "x^2".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let pos = get_variable_positions(&parsed_poly, vec!["x".to_string()]);
        let final_variable = handle_mult_constraint(&parsed_poly, pos["x"], pos["x"]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }
    
    #[test]
    fn test_higher_exponentiation() {
        let polynomial = "x^8".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let pos = get_variable_positions(&parsed_poly, vec!["x".to_string()]);
        let mut final_variable = pos["x"];
        for _ in 0..3 {
            final_variable = handle_mult_constraint(&parsed_poly, final_variable, final_variable);
        }
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_odd_exponentiation() {
        let polynomial = "x^3".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let mut pos = get_variable_positions(&parsed_poly, vec!["x".to_string()]);
        pos.insert("x^2".to_string(), handle_mult_constraint(&parsed_poly, pos["x"], pos["x"]));
        let final_variable = handle_mult_constraint(&parsed_poly, pos["x"], pos["x^2"]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_complicated_exponentiation() {
        let polynomial = "x^13".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let mut pos = get_variable_positions(&parsed_poly, vec!["x".to_string()]);
        pos.insert("x^2".to_string(), handle_mult_constraint(&parsed_poly, pos["x"], pos["x"]));
        pos.insert("x^3".to_string(), handle_mult_constraint(&parsed_poly, pos["x"], pos["x^2"]));
        pos.insert("x^6".to_string(), handle_mult_constraint(&parsed_poly, pos["x^3"], pos["x^3"]));
        pos.insert("x^12".to_string(), handle_mult_constraint(&parsed_poly, pos["x^6"], pos["x^6"]));
        let final_variable = handle_mult_constraint(&parsed_poly, pos["x"], pos["x^12"]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_parenthesis() {
        let polynomial = "(x + y) + z".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let mut pos = get_variable_positions(&parsed_poly, vec!["x".to_string(), "y".to_string(), "z".to_string()]);
        pos.insert("(x + y)".to_string(), handle_add_constraint(&parsed_poly, vec![(pos["x"],1), (pos["y"], 1)]));
        let final_variable = handle_add_constraint(&parsed_poly, vec![(pos["(x + y)"],1), (pos["z"],1)]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_parenthesis_with_exponentiation() {
        let polynomial = "(x + y)^7".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let mut pos = get_variable_positions(&parsed_poly, vec!["x".to_string(), "y".to_string()]);
        pos.insert("(x + y)".to_string(), handle_add_constraint(&parsed_poly, vec![(pos["x"],1), (pos["y"],1)]));
        pos.insert("(x + y)^2".to_string(), handle_mult_constraint(&parsed_poly, pos["(x + y)"], pos["(x + y)"]));  
        pos.insert("(x + y)^3".to_string(), handle_mult_constraint(&parsed_poly, pos["(x + y)"], pos["(x + y)^2"]));
        pos.insert("(x + y)^6".to_string(), handle_mult_constraint(&parsed_poly, pos["(x + y)^3"], pos["(x + y)^3"]));
        let final_variable = handle_mult_constraint(&parsed_poly, pos["(x + y)"], pos["(x + y)^6"]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_handle_recurring_variable() {
        let polynomial = "x + x*x".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let mut pos = get_variable_positions(&parsed_poly, vec!["x".to_string()]);
        pos.insert("x*x".to_string(), handle_mult_constraint(&parsed_poly, pos["x"], pos["x"]));
        let final_variable = handle_add_constraint(&parsed_poly, vec![(pos["x"],1), (pos["x*x"],1)]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_repeated_exponentiation() {
        let polynomial = "(89(6x^3)^4)^2".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let mut pos = get_variable_positions(&parsed_poly, vec!["x".to_string()]);
        pos.insert("x^2".to_string(), handle_mult_constraint(&parsed_poly, pos["x"], pos["x"]));
        pos.insert("x^3".to_string(), handle_mult_constraint(&parsed_poly, pos["x"], pos["x^2"]));
        pos.insert("6x^3".to_string(), handle_const_mult_constraint(&parsed_poly, 6, pos["x^3"]));
        pos.insert("(6x^3)^2".to_string(), handle_mult_constraint(&parsed_poly, pos["6x^3"], pos["6x^3"]));
        pos.insert("(6x^3)^4".to_string(), handle_mult_constraint(&parsed_poly, pos["(6x^3)^2"], pos["(6x^3)^2"]));
        pos.insert("89(6x^3)^4".to_string(), handle_const_mult_constraint(&parsed_poly, 89, pos["(6x^3)^4"]));
        let final_variable = handle_mult_constraint(&parsed_poly, pos["89(6x^3)^4"], pos["89(6x^3)^4"]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_complicated_product () {
        let polynomial = "(7x^5)^4(5x+t)^8*4x".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let mut pos = get_variable_positions(&parsed_poly, vec!["x".to_string(), "t".to_string()]);
        pos.insert("x^2".to_string(), handle_mult_constraint(&parsed_poly, pos["x"], pos["x"]));
        pos.insert("x^4".to_string(), handle_mult_constraint(&parsed_poly, pos["x^2"], pos["x^2"]));
        pos.insert("x^5".to_string(), handle_mult_constraint(&parsed_poly, pos["x"], pos["x^4"]));
        pos.insert("7x^5".to_string(), handle_const_mult_constraint(&parsed_poly, 7, pos["x^5"]));
        pos.insert("(7x^5)^2".to_string(), handle_mult_constraint(&parsed_poly, pos["7x^5"], pos["7x^5"]));
        pos.insert("(7x^5)^4".to_string(), handle_mult_constraint(&parsed_poly, pos["(7x^5)^2"], pos["(7x^5)^2"]));
    }

    #[test]
    fn test_simple_difference () {
        let polynomial = "x - y".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let pos = get_variable_positions(&parsed_poly, vec!["x".to_string(), "y".to_string()]);
        let final_variable = handle_add_constraint(&parsed_poly, vec![(pos["x"],1), (pos["y"],-1)]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_complicated_sum_with_negatives () {
        let polynomial = "x - y - z + a - b + t + s - p".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let pos = get_variable_positions(&parsed_poly, vec!["x".to_string(), "y".to_string(), "z".to_string(), "a".to_string(), "b".to_string(), "t".to_string(), "s".to_string(), "p".to_string()]);
        let final_variable = handle_add_constraint(&parsed_poly, vec![(pos["x"],1), (pos["y"],-1), (pos["z"],-1), (pos["a"],1), (pos["b"],-1), (pos["t"],1), (pos["s"],1), (pos["p"],-1)]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_sum_starting_with_negatives () {
        let polynomial = "-x - y + z".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let pos = get_variable_positions(&parsed_poly, vec!["x".to_string(), "y".to_string(), "z".to_string()]);
        let final_variable = handle_add_constraint(&parsed_poly, vec![(pos["x"],-1), (pos["y"],-1), (pos["z"],1)]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_only_negative () {
        let polynomial = "-x".to_string();
        let expected_result = 10;
        let parsed_poly = parse(polynomial, expected_result);
        parsed_poly.print();
        let pos = get_variable_positions(&parsed_poly, vec!["x".to_string()]);
        let final_variable = handle_add_constraint(&parsed_poly, vec![(pos["x"],-1)]);
        check_final_constraint(&parsed_poly, final_variable, expected_result);
    }

    #[test]
    fn test_poly2r1cs() {
        let polynomial = "3*x^2 + 2*x - 5".to_string();
        let result = poly2r1cs(polynomial, 2);
        assert!(result.is_ok());
    }
}